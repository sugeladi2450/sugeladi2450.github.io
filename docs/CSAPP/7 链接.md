### 1. 链接器如何解析引用（Symbol Resolution）？

在编译阶段，编译器只看当前文件。如果你在 `main.c` 里调用了 `foo()`，但 `foo` 是在另一个文件定义的，编译器会在生成的 `main.o` 的符号表中留一个“坑”（未定义的符号引用），标记为 **UND**（Undefined）。

链接器的工作就是**填坑**。

#### 基本逻辑

链接器维护这一张全局的“符号表”。它的解析过程可以简化为：

1. **输入：** 扫描所有的输入目标文件（`.o`）。
2. **匹配：** 发现 `main.o` 里有一个对 `foo` 的引用（坑），它就会去其他 `.o` 文件的符号表里找，看谁定义了 `foo`（萝卜）。
3. **关联：** 一旦找到定义（比如在 `foo.o` 中），链接器就会把 `main.o` 中的那个引用指向 `foo.o` 中函数的内存地址。

#### 强符号与弱符号（Strong vs Weak）

如果在多个文件里都定义了 `foo` 怎么办？链接器遵循以下规则：

* **强符号：** 函数和初始化的全局变量。
* **弱符号：** 未初始化的全局变量。
* **规则 1：** 不允许有多个同名的强符号。（否则报错：`multiple definition`）
* **规则 2：** 如果有一个强符号和多个弱符号，选强符号。
* **规则 3：** 如果只有多个弱符号，随机选一个。

---

### 2. 什么是库（Library）？

想象一下，如果没有库，你想用 `printf`，你就必须把 C 标准库的所有源代码（几千个文件）都重新编译一遍，或者手动把对应的 `.o` 文件一个个加到你的编译命令里。这太痛苦了。

**库（Library）** 本质上就是**相关目标文件（.o）的打包集合**。

#### 静态库（Static Library, .a / .lib）

在 Linux 下通常是 `.a` 文件（Archive）。

* **本质：** 它就像一个 `.zip` 包，里面塞了一堆 `.o` 文件（比如 `printf.o`, `scanf.o`, `malloc.o`...）。
* **特点：** 链接器在链接时，会把库里**被用到**的那部分 `.o` 拿出来，复制到你的可执行文件中。没用到的部分如果不拿。

#### 动态库（Shared Library, .so / .dll）

这是现代系统更常用的。链接时只记录“我需要用到这个库”的信息，不复制具体代码。程序运行时，操作系统才把库加载到内存。

---

### 3. 如何使用库来解析引用？（核心算法）

这是很多学生容易晕的地方，也是 CS:APP 中的考点。链接器在处理静态库时，是**按照命令行中出现的顺序，从左到右扫描的**。

链接器维护了三个集合：

* ** (Executable)：** 将要被合并到可执行文件中的目标文件集合。
* ** (Undefined)：** 当前引用了但还未找到定义的符号集合（未填的坑）。
* ** (Defined)：** 当前已扫描过的文件中定义的符号集合（已有的萝卜）。

#### 扫描算法流程：

1. **初始状态：** 、、 均为空。
2. **按顺序扫描：** 链接器根据命令行参数，从左到右处理文件（.o 或 .a）。
3. **如果遇到目标文件（.o）：**
* 把它加入 。
* 更新  和 （把这个文件里的新定义放入 ，新引用放入 ，如果  里有能填补  的，就从  移除）。


4. **如果遇到静态库（.a）：**
* 链接器会遍历库里的所有 `.o` 成员。
* **关键判断：** 只有当库里的某个 `.o` 定义了一个**当前在  集合中**的符号时，链接器才会把这个 `.o` 提取出来放入 。
* 如果库里的 `.o` 没有被需要（即它定义的符号不在  中），直接忽略。
* 这个过程会反复进行，直到  和  不再变化。


5. **结束检查：** 扫描完所有参数后，如果  集合不为空（还有坑没填上），链接器报错 `undefined reference`。

---

### 4. 一个经典的“坑”：顺序很重要

基于上面的算法，库在命令行中的位置至关重要。

#### 正确的写法：

```bash
gcc main.c -lm

```

1. 链接器先看 `main.c`（转为 `main.o`）。
2. `main.o` 调用了 `sin()`。此时 ，。
3. 链接器看 `-lm`（数学库 libm.a）。
4. 发现库里的 `sin.o` 定义了 `sin`，而 `sin` 在  里。
5. 提取 `sin.o` 加入 。 清空。
6. 成功。

#### 错误的写法：

```bash
gcc -lm main.c

```

1. 链接器先看 `-lm`。
2. 此时  是空的（没人需要任何符号）。
3. 链接器认为：“哦，这个库里的东西现在都没人要”，于是**完全丢弃**数学库。
4. 链接器看 `main.c`。
5. `main.o` 加入 ，它需要 `sin()`，放入 。
6. 后面没有文件了。
7. 报错：`undefined reference to 'sin'`。

### 总结

* **解析引用**就是把“未定义的符号”和“定义的符号”配对。
* **库**就是一堆 `.o` 文件的压缩包。
* **使用库解析**通过维护 （未定义集合）来实现，只有当库里的模块能填补当前的  时，才会被链接进来。所以，**库文件通常要放在命令行的最后面**。