### 1. 链接器如何解析引用（Symbol Resolution）？

在编译阶段，编译器只看当前文件。如果你在 `main.c` 里调用了 `foo()`，但 `foo` 是在另一个文件定义的，编译器会在生成的 `main.o` 的符号表中留一个“坑”（未定义的符号引用），标记为 **UND**（Undefined）。

链接器的工作就是**填坑**。

#### 基本逻辑

链接器维护这一张全局的“符号表”。它的解析过程可以简化为：

1. **输入：** 扫描所有的输入目标文件（`.o`）。
2. **匹配：** 发现 `main.o` 里有一个对 `foo` 的引用（坑），它就会去其他 `.o` 文件的符号表里找，看谁定义了 `foo`（萝卜）。
3. **关联：** 一旦找到定义（比如在 `foo.o` 中），链接器就会把 `main.o` 中的那个引用指向 `foo.o` 中函数的内存地址。

#### 强符号与弱符号（Strong vs Weak）

如果在多个文件里都定义了 `foo` 怎么办？链接器遵循以下规则：

* **强符号：** 函数和初始化的全局变量。
* **弱符号：** 未初始化的全局变量。
* **规则 1：** 不允许有多个同名的强符号。（否则报错：`multiple definition`）
* **规则 2：** 如果有一个强符号和多个弱符号，选强符号。
* **规则 3：** 如果只有多个弱符号，随机选一个。

---

### 2. 什么是库（Library）？

想象一下，如果没有库，你想用 `printf`，你就必须把 C 标准库的所有源代码（几千个文件）都重新编译一遍，或者手动把对应的 `.o` 文件一个个加到你的编译命令里。这太痛苦了。

**库（Library）** 本质上就是**相关目标文件（.o）的打包集合**。

#### 静态库（Static Library, .a / .lib）

在 Linux 下通常是 `.a` 文件（Archive）。

* **本质：** 它就像一个 `.zip` 包，里面塞了一堆 `.o` 文件（比如 `printf.o`, `scanf.o`, `malloc.o`...）。
* **特点：** 链接器在链接时，会把库里**被用到**的那部分 `.o` 拿出来，复制到你的可执行文件中。没用到的部分如果不拿。

#### 动态库（Shared Library, .so / .dll）

这是现代系统更常用的。链接时只记录“我需要用到这个库”的信息，不复制具体代码。程序运行时，操作系统才把库加载到内存。

---

### 3. 如何使用库来解析引用？（核心算法）

这是很多学生容易晕的地方，也是 CS:APP 中的考点。链接器在处理静态库时，是**按照命令行中出现的顺序，从左到右扫描的**。

链接器维护了三个集合：

* **E(Executable)：** 将要被合并到可执行文件中的目标文件集合。
* **U(Undefined)：** 当前引用了但还未找到定义的符号集合（未填的坑）。
* **D(Defined)：** 当前已扫描过的文件中定义的符号集合（已有的萝卜）。

#### 扫描算法流程：

1. **初始状态：** E、U、D 均为空。
2. **按顺序扫描：** 链接器根据命令行参数，从左到右处理文件（.o 或 .a）。
3. **如果遇到目标文件（.o）：**
* 把它加入 E。
* 更新 U 和 D（把这个文件里的新定义放入 D，新引用放入 U，如果  D里有能填补 U 的，就从 U 移除）。


4. **如果遇到静态库（.a）：**
* 链接器会遍历库里的所有 `.o` 成员。
* **关键判断：** 只有当库里的某个 `.o` 定义了一个**当前在 U 集合中**的符号时，链接器才会把这个 `.o` 提取出来放入 E。
* 如果库里的 `.o` 没有被需要（即它定义的符号不在 U 中），直接忽略。
* 这个过程会反复进行，直到 U 和 D 不再变化。


5. **结束检查：** 扫描完所有参数后，如果 U 集合不为空（还有坑没填上），链接器报错 `undefined reference`。

---

### 4. 一个经典的“坑”：顺序很重要

基于上面的算法，库在命令行中的位置至关重要。

#### 正确的写法：

```bash
gcc main.c -lm

```

1. 链接器先看 `main.c`（转为 `main.o`）。
2. `main.o` 调用了 `sin()`。此时 E = main.o，U = sin。
3. 链接器看 `-lm`（数学库 libm.a）。
4. 发现库里的 `sin.o` 定义了 `sin`，而 `sin` 在 U 里。
5. 提取 `sin.o` 加入 E。U 清空。
6. 成功。

#### 错误的写法：

```bash
gcc -lm main.c

```

1. 链接器先看 `-lm`。
2. 此时 U 是空的（没人需要任何符号）。
3. 链接器认为：“哦，这个库里的东西现在都没人要”，于是**完全丢弃**数学库。
4. 链接器看 `main.c`。
5. `main.o` 加入 E，它需要 `sin()`，放入 U。
6. 后面没有文件了。
7. 报错：`undefined reference to 'sin'`。

### 总结

* **解析引用**就是把“未定义的符号”和“定义的符号”配对。
* **库**就是一堆 `.o` 文件的压缩包。
* **使用库解析**通过维护 U（未定义集合）来实现，只有当库里的模块能填补当前的 U 时，才会被链接进来。所以，**库文件通常要放在命令行的最后面**。


---

### 1. 全局变量 vs. 局部变量

#### 局部变量 (Local Variables)

* **定义位置：** 函数内部（包括 `main` 函数）或代码块 `{ ... }` 内部。
* **存储位置：** **栈 (Stack)**。
* **生存期：** **临时**。代码执行到定义处时创建，出了那个 `{}` 作用域就自动销毁（内存被释放）。
* **作用域：** 只有定义它的那个代码块内部能看到。
* **初始化：** 默认**不会自动初始化**（值是内存里的垃圾值），必须手动赋值。

#### 全局变量 (Global Variables)

* **定义位置：** 所有函数外部。
* **存储位置：** **数据段 (Data Segment / .data)** 或 **BSS 段 (.bss)**。
* **生存期：** **永久**。程序一开始运行就创建，直到程序结束才销毁。
* **作用域：** 默认情况下，整个程序的**所有文件**都能看到（只要用 `extern` 声明一下）。
* **初始化：** 默认**自动初始化为 0**。

| 特性 | 局部变量 | 全局变量 |
| --- | --- | --- |
| **存在哪里？** | 栈 (Stack) | 数据段 (Data/BSS) |
| **活多久？** | 函数执行期间 | 程序运行全程 |
| **谁能用？** | 只有本函数 | 所有文件 (配合 extern) |
| **默认值？** | 随机垃圾值 | 0 |

---

### 2. static 到底意味着什么？

`static` 是 C/C++ 中最容易让人晕的关键字，因为它的含义**取决于它用在哪里**。它主要有两个作用：**改变可见性**（链接属性）和 **改变生存期**（存储位置）。

#### 用法 A：修饰全局变量或函数（改变可见性）

当你在一个全局变量或函数前加上 `static`，你是在告诉链接器：“**这个东西是私有的，别让其他文件看见！**”

* **没有 static：** 全局变量/函数是 `global` 符号，其他 `.c` 文件可以通过 `extern` 引用它。
* **加上 static：** 它们变成了 **文件作用域 (File Scope)** 的局部符号。其他文件完全看不到它，甚至可以在其他文件里定义一个同名的东西而不冲突。

**场景举例：**

* `file1.c`: `static int secret = 42;`
* `file2.c`: `int secret = 100;` // 完全没问题，两个 `secret` 互不干扰。

> **链接器视角：** `static` 修饰的全局变量，符号表中标记为 `LOCAL`，而不是 `GLOBAL`。链接器在处理重定位时，绝不会把它暴露给其他模块。

#### 用法 B：修饰局部变量（改变生存期）

当你在函数内部定义的变量前加上 `static`，你是在告诉编译器：“**把它存在数据段里，别存在栈上！**”

* **普通局部变量：** 每次调用函数都会重新创建，函数结束就消失。
* **Static 局部变量：**
1. **存储位置：** 从栈搬到了 **数据段 (.data/.bss)**（和全局变量在一起）。
2. **生存期：** 变成了 **永久**。它只在第一次调用函数时初始化一次，之后函数结束它依然存在，保留着上次的值。
3. **作用域：** 依然被限制在函数内部，外面看不见。



**代码示例：**

```c
void count_calls() {
    static int counter = 0; // 只在程序启动时初始化一次
    counter++;
    printf("I have been called %d times\n", counter);
}

int main() {
    count_calls(); // 输出 1
    count_calls(); // 输出 2 (它记得上次的值！)
    count_calls(); // 输出 3
}

```

### 总结一张表

| 写在哪里 | 加上 static 的效果 | 术语变化 |
| --- | --- | --- |
| **函数外** (全局变量/函数) | **限制作用域**：只能在当前文件中使用，其他文件不可见。 | 内部链接 (Internal Linkage) |
| **函数内** (局部变量) | **延长生存期**：从栈移到数据段，函数结束后值不丢失。 | 静态存储期 (Static Storage Duration) |

**简单记忆法：**

* **对全局的加 static：** 为了**隐蔽**（不让别的文件乱动）。
* **对局部的加 static：** 为了**记忆**（记住上次算出的值）。

这四个概念是层层递进的：

1. **虚拟内存**是宏观的“蓝图”。
2. **分页**是实现这个蓝图的“积木”。
3. **内存映射**是把文件（如 `.exe`）连接到蓝图的“桥梁”。
4. **加载和运行**就是利用以上机制的“全过程”。

---

### 1. 虚拟内存 (Virtual Memory)：伟大的谎言

虚拟内存是操作系统给每个进程制造的一个**幻觉**。

* **幻觉：** 每个程序都认为自己独占整个计算机的内存，拥有连续的、巨大的地址空间（比如从 `0x0000` 到 `0xFFFF...`）。
* **现实：** 物理内存（RAM）不仅很小，而且被很多程序共享，甚至碎片化了。
* **作用：**
1. **隔离保护：** 如果你的程序崩溃了，或者试图乱写数据，它只会破坏自己的虚拟空间，无法影响其他程序或操作系统。
2. **简化编程：** 链接器在生成可执行文件时，只需要给代码和数据分配**虚拟地址**，完全不用操心这台电脑到底插了多少内存条。



### 2. 分页 (Paging)：管理的最小单位

操作系统怎么实现虚拟内存这个幻觉呢？它不能以字节为单位管理（太慢），也不能以整个程序为单位（太浪费）。它使用**“页（Page）”**。

* **切分：** 虚拟内存被切成固定大小的块（通常是 **4KB**），叫做**虚拟页 (VP)**。物理内存也被切成同样大小的块，叫做**物理页 (PP)** 或 **页帧 (Page Frame)**。
* **页表 (Page Table)：** 这是一个存放在内存里的“字典”。
* **键 (Key)：** 虚拟页号。
* **值 (Value)：** 物理页号（如果该页在内存中） 或者 磁盘地址（如果该页在磁盘上）。


* **MMU (内存管理单元)：** CPU 里的一个硬件。当你代码里访问地址 `0x1000` 时，MMU 迅速查表，把它翻译成物理地址 `0x5000`（假设映射到了物理内存的第 5 页）。

如果 MMU 发现这个虚拟页**不在**物理内存中（比如标记为“未缓存”），就会触发**缺页异常 (Page Fault)**。这时操作系统醒来，把数据从磁盘拷贝到内存，更新页表，然后让程序继续运行。

### 3. 内存映射 (Memory Mapping)：磁盘到内存的桥梁

这是理解“加载程序”的关键。

传统的文件读取是：`磁盘 -> 内核缓冲区 -> 用户缓冲区`（发生了多次拷贝）。
**内存映射 (Memory Mapping, mmap)** 是：告诉操作系统，“把磁盘上的这个文件（比如 `hello.exe`），对应到我的虚拟内存的这段区域”。

* **并不立即拷贝：** 映射只是在页表里登记了一下：“这段虚拟内存对应那个文件的数据”。此时，**物理内存里还是空的**。
* **按需加载 (Lazy Loading)：** 当程序真的读到这段地址时，触发**缺页异常**，操作系统才真的把文件内容搬到物理内存。

### 4. 加载和运行程序 (Loading and Running)

把上面三个概念串起来，就是你在 Shell 里输入 `./program` 后发生的事情：

假设你要运行 `prog`（一个编译好的可执行文件）。

#### 第一步：创建新进程 (Fork)

Shell 调用 `fork()` 函数，创建一个新的子进程。此时子进程拥有独立但空的页表。

#### 第二步：执行加载器 (Execve)

子进程调用 `execve("prog", ...)`，加载器（Loader）开始工作：

1. **删除旧映射：** 清空当前进程已有的虚拟内存映射（忘掉旧的自己）。
2. **创建新映射 (Mapping)：**
* **代码段 (.text)：** 映射到 `prog` 文件的代码部分。
* **数据段 (.data)：** 映射到 `prog` 文件的数据部分。
* **BSS 段 (.bss)：** 映射到**匿名文件**（请求二进制零）。这部分变量不需要从磁盘读，直接填 0。
* **堆和栈：** 设置初始长度。


3. **设置入口点：** 加载器把 CPU 的指令寄存器 (PC) 指向程序的入口点（通常是链接器设置的 `_start` 地址）。

#### 第三步：开始执行 (The Magic)

注意，到现在为止，**没有任何代码或数据被真的读入物理内存！**

1. CPU 试图读取第一条指令。
2. MMU 查表，发现：“哎？这个虚拟页虽然映射了文件，但不在物理内存里！” -> **触发缺页异常**。
3. 操作系统接管，看着页表说：“哦，这页对应 `prog` 文件的开头 4KB。”
4. 操作系统把这 4KB 从磁盘读入物理内存，更新页表。
5. CPU 重新执行刚才那条指令。这一次，命中了物理内存，程序开始跑了。

### 总结

* **虚拟内存**给了程序一张巨大的、干净的白纸。
* **分页**是操作系统在这张白纸上画格子的方式。
* **内存映射**是把磁盘上的文件内容“投影”到这些格子里。
* **加载程序**本质上就是**建立映射**，然后利用**缺页异常**机制，让程序在运行时“边跑边加载”数据。这就是为什么很大的游戏瞬间就能打开，但进去后可能要加载一会儿的原因。